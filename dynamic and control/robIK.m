function [ is_solution, joint_angles ] = robIK( pos, prev_joint_angles, rob )
% MECH 498/598 - Intro to Robotics - Spring 2016
% Lab 3
% Solutions by Craig McDonald
% 
%    Compute all inverse kinematics solutions for the robot in a
%    particular pose.
%    
%    pos is a 3-element vector that describes the end effector pose
%
%    prev_joint_angles is a 6-element vector containing the robot joint
%    angles for its previous position
%
%    rob is a structure generated by robInit()
%
%    is_solution is a boolean reporting whether or not a feasible solution
%    exists
%
%    joint_angles is a 6-element vector containing the "nearest" solution
%
%

% Rename parameter variables for convenience
l1 = rob.parameters.l1;
l2 = rob.parameters.l2;
l3 = rob.parameters.l3;

% End effector position
p_x = pos(1);
p_y = pos(2);
p_z = pos(3);

% Arm IK Solution
theta_1 = [ atan2(p_y,p_x);
            atan2(-p_y,-p_x)];        
p_x1 = p_x./cos(theta_1);
p_z1 = p_z-l1;
c3 = (p_x1(1).^2+p_z1^2-l2^2-l3^2)/(2*l2*l3);   
s3 = [sqrt(1-c3^2),-sqrt(1-c3^2)];
theta_3 = [ atan2(s3(1),c3);
            atan2(s3(2),c3)];
phi = [ atan2(p_z1,p_x1(1));
        atan2(p_z1,p_x1(2))];
beta = [ atan2(l3*s3(1),l2+l3*c3);
         atan2(l3*s3(2),l2+l3*c3)];
theta_1 = [theta_1(1);theta_1(1);theta_1(2);theta_1(2)];
theta_2 = [phi(1)+beta(2);phi(1)+beta(1);phi(2)+beta(2);phi(2)+beta(1)];
theta_3 = [theta_3(1);theta_3(2);theta_3(1);theta_3(2)];
thetas = [theta_1,theta_2,theta_3];


% Check joint limits
bad_sol = false(size(thetas,1),1);
for i = 1:size(thetas,1)
    for j = 1:size(thetas,2)
        while thetas(i,j) < rob.joint_limits{j}(1)-1e-8
            thetas(i,j) = thetas(i,j) + 2*pi;
        end
        while thetas(i,j) > rob.joint_limits{j}(2)+1e-8
            thetas(i,j) = thetas(i,j) - 2*pi;
        end
        if thetas(i,j) < rob.joint_limits{j}(1)-1e-8
            bad_sol(i) = true;
        end
    end
end
thetas(bad_sol,:) = []; % remove solutions outside of joint ranges

% Check for solutions, and find "nearest" solution
if isempty(thetas)
    is_solution = false;
    joint_angles = [];
    warning('no solution');

else
    is_solution = true;
    i = 1;
    while size(thetas,1) > 1
        theta_diff = abs(prev_joint_angles(i)-thetas(:,i));
        thetas = thetas(theta_diff==min(theta_diff),:);
        i = i + 1;
        if i > size(thetas,2)
            thetas = thetas(1,:);
        end
    end
    joint_angles = thetas(1,:);
end       


end

